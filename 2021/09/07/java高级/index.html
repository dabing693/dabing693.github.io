<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java高级 | 小辉博客</title><meta name="description" content="java接口接口是从多个相似类中抽象出来的规范，接口不提供任何实现。 接口体现的是规范和实现分离的设计哲学。 接口定义的是多个类共同的公共行为规范，这些行为是与外部交流的通道，这就意味着接口里通常是定义一组公用方法。 1、接口定义的语法：接口定义的是多个类共同的公共 1234[修饰符] interface 接口名 extends 父接口1,父接口2...&amp;#123;零到多个常量定义零到多个抽象方法"><meta name="author" content="dabing693"><meta name="copyright" content="dabing693"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2021/09/07/java%E9%AB%98%E7%BA%A7/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="java高级"><meta property="og:url" content="http://yoursite.com/2021/09/07/java%E9%AB%98%E7%BA%A7/"><meta property="og:site_name" content="小辉博客"><meta property="og:description" content="java接口接口是从多个相似类中抽象出来的规范，接口不提供任何实现。 接口体现的是规范和实现分离的设计哲学。 接口定义的是多个类共同的公共行为规范，这些行为是与外部交流的通道，这就意味着接口里通常是定义一组公用方法。 1、接口定义的语法：接口定义的是多个类共同的公共 1234[修饰符] interface 接口名 extends 父接口1,父接口2...&amp;#123;零到多个常量定义零到多个抽象方法"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2021-09-07T13:51:08.263Z"><meta property="article:modified_time" content="2021-01-02T12:16:27.753Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="Mybatis IDEA版教程" href="http://yoursite.com/2021/09/07/Mybatis%20IDEA%E7%89%88%E6%95%99%E7%A8%8B/"><link rel="next" title="javaweb教程" href="http://yoursite.com/2021/09/07/javaweb/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="小辉博客" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://ae01.alicdn.com/kf/Hf828ff298f76464d9b00ad99cb873415F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">9</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">3</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java接口"><span class="toc-number">1.</span> <span class="toc-text">java接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java容器"><span class="toc-number">2.</span> <span class="toc-text">java容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#常用容器的图录（部分）"><span class="toc-number">2.1.</span> <span class="toc-text">常用容器的图录（部分）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">2.2.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-number">2.2.1.</span> <span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inkedList"><span class="toc-number">2.2.2.</span> <span class="toc-text">inkedList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Queue"><span class="toc-number">2.3.</span> <span class="toc-text">Queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-number">2.4.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">2.5.</span> <span class="toc-text">Map</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java异常"><span class="toc-number">3.</span> <span class="toc-text">java异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#异常概述"><span class="toc-number">3.1.</span> <span class="toc-text">异常概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常处理机制"><span class="toc-number">3.2.</span> <span class="toc-text">异常处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用try…catch捕获异常"><span class="toc-number">3.2.1.</span> <span class="toc-text">使用try…catch捕获异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常类的继承体系"><span class="toc-number">3.2.2.</span> <span class="toc-text">异常类的继承体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-7提供的多异常捕获"><span class="toc-number">3.2.3.</span> <span class="toc-text">Java 7提供的多异常捕获</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问异常信息"><span class="toc-number">3.2.4.</span> <span class="toc-text">访问异常信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用finally回收资源"><span class="toc-number">3.2.5.</span> <span class="toc-text">使用finally回收资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常处理的嵌套"><span class="toc-number">3.2.6.</span> <span class="toc-text">异常处理的嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-7的自动关闭资源的try语句"><span class="toc-number">3.2.7.</span> <span class="toc-text">Java 7的自动关闭资源的try语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Checked异常和Runtime异常体系"><span class="toc-number">3.3.</span> <span class="toc-text">Checked异常和Runtime异常体系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用throws声明抛出异常"><span class="toc-number">3.3.1.</span> <span class="toc-text">使用throws声明抛出异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用throw抛出异常"><span class="toc-number">3.4.</span> <span class="toc-text">使用throw抛出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#抛出异常"><span class="toc-number">3.4.1.</span> <span class="toc-text">抛出异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义异常类"><span class="toc-number">3.4.2.</span> <span class="toc-text">自定义异常类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java的异常跟踪栈"><span class="toc-number">3.5.</span> <span class="toc-text">Java的异常跟踪栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java泛型"><span class="toc-number">4.</span> <span class="toc-text">java泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型入门"><span class="toc-number">4.1.</span> <span class="toc-text">泛型入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深入泛型"><span class="toc-number">4.2.</span> <span class="toc-text">深入泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#从泛型类派生子类"><span class="toc-number">4.2.1.</span> <span class="toc-text">从泛型类派生子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并不存在泛型类"><span class="toc-number">4.2.2.</span> <span class="toc-text">并不存在泛型类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型通配符"><span class="toc-number">4.3.</span> <span class="toc-text">类型通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用类型通配符"><span class="toc-number">4.3.1.</span> <span class="toc-text">使用类型通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设定类型通配符的上限"><span class="toc-number">4.3.2.</span> <span class="toc-text">设定类型通配符的上限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设定类型形参的上限"><span class="toc-number">4.3.3.</span> <span class="toc-text">设定类型形参的上限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型方法"><span class="toc-number">4.4.</span> <span class="toc-text">泛型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型方法和类型通配符的区别"><span class="toc-number">4.4.1.</span> <span class="toc-text">泛型方法和类型通配符的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-7的“菱形”语法与泛型构造器"><span class="toc-number">4.4.2.</span> <span class="toc-text">Java 7的“菱形”语法与泛型构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设定通配符下限"><span class="toc-number">4.4.3.</span> <span class="toc-text">设定通配符下限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型方法与方法重载"><span class="toc-number">4.4.4.</span> <span class="toc-text">泛型方法与方法重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#擦除和转换"><span class="toc-number">4.4.5.</span> <span class="toc-text">擦除和转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型与数组"><span class="toc-number">4.4.6.</span> <span class="toc-text">泛型与数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java注解"><span class="toc-number">5.</span> <span class="toc-text">java注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本Annotation"><span class="toc-number">5.1.</span> <span class="toc-text">基本Annotation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK的元Annotation"><span class="toc-number">5.2.</span> <span class="toc-text">JDK的元Annotation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义Annotation"><span class="toc-number">5.3.</span> <span class="toc-text">自定义Annotation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Annotation的示例"><span class="toc-number">5.4.</span> <span class="toc-text">使用Annotation的示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编译时处理Annotation"><span class="toc-number">5.5.</span> <span class="toc-text">编译时处理Annotation</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java反射"><span class="toc-number">6.</span> <span class="toc-text">java反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一个简单的例子"><span class="toc-number">6.1.</span> <span class="toc-text">一个简单的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射常用API"><span class="toc-number">6.2.</span> <span class="toc-text">反射常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#获取反射中的Class对象"><span class="toc-number">6.2.1.</span> <span class="toc-text">获取反射中的Class对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过反射创建类对象"><span class="toc-number">6.2.2.</span> <span class="toc-text">通过反射创建类对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过反射获取类属性、方法、构造器"><span class="toc-number">6.2.3.</span> <span class="toc-text">通过反射获取类属性、方法、构造器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射源码解析"><span class="toc-number">6.3.</span> <span class="toc-text">反射源码解析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java-I-O"><span class="toc-number">7.</span> <span class="toc-text">java I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO概念"><span class="toc-number">7.1.</span> <span class="toc-text">IO概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#“流”是什么？"><span class="toc-number">7.2.</span> <span class="toc-text">“流”是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO流的分类"><span class="toc-number">7.3.</span> <span class="toc-text">IO流的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#按照流的方向"><span class="toc-number">7.3.1.</span> <span class="toc-text">按照流的方向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#按照流的操作颗粒度划分"><span class="toc-number">7.3.2.</span> <span class="toc-text">按照流的操作颗粒度划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#按照流的角色划分"><span class="toc-number">7.3.3.</span> <span class="toc-text">按照流的角色划分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流的原理以及IO流汇总"><span class="toc-number">7.4.</span> <span class="toc-text">流的原理以及IO流汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#流的原理解析"><span class="toc-number">7.4.1.</span> <span class="toc-text">流的原理解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java中所有流汇总"><span class="toc-number">7.4.2.</span> <span class="toc-text">java中所有流汇总</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见IO流的实战"><span class="toc-number">7.5.</span> <span class="toc-text">常见IO流的实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#访问操作文件"><span class="toc-number">7.5.1.</span> <span class="toc-text">访问操作文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存流的使用"><span class="toc-number">7.5.2.</span> <span class="toc-text">缓存流的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换流的使用"><span class="toc-number">7.5.3.</span> <span class="toc-text">转换流的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象流的使用"><span class="toc-number">7.5.4.</span> <span class="toc-text">对象流的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字节数组流的使用"><span class="toc-number">7.5.5.</span> <span class="toc-text">字节数组流的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java图形化"><span class="toc-number">8.</span> <span class="toc-text">java图形化</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">小辉博客</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">java高级</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-09-07 21:51:08"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2021-09-07</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-01-02 20:16:27"><i class="fas fa-history fa-fw"></i> 更新于 2021-01-02</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="java接口"><a href="#java接口" class="headerlink" title="java接口"></a>java接口</h1><p>接口是从多个相似类中抽象出来的规范，接口不提供任何实现。</p>
<p>接口体现的是规范和实现分离的设计哲学。</p>
<p>接口定义的是多个类共同的公共行为规范，这些行为是与外部交流的通道，这就意味着接口里通常是定义一组公用方法。</p>
<p>1、接口定义的语法：接口定义的是多个类共同的公共</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="class"><span class="keyword">interface</span> 接口名 <span class="keyword">extends</span> 父接口1,父接口2...</span>&#123;</span><br><span class="line">零到多个常量定义</span><br><span class="line">零到多个抽象方法定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果省略了public访问控制符，则默认采用包权限访问控制符。</li>
<li>仅从语法角度来看，接口名只要是合法的标识符即可；要遵守Java可读性规范，则接口名应由多个有意义的单词连缀而成，每个单词首字母大写。</li>
<li>一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类。</li>
</ul>
<p>由于接口定义的是一种规范，因此接口里不能包含构造器和初始化块定义。接口里可以包含Field （只能是常量）、方法（只能是抽象实例方法）、内部类（包括内部接口、枚举）定义。</p>
<p>接口里的所有成员，包括常量、方法、内部类和枚举类都是public访问权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;系统会自动为接口定义的Field增加public static final修饰符</span><br><span class="line">int MAX_SIZE&#x3D;50;</span><br><span class="line">public static final int MAX_SIZE&#x3D;50;</span><br></pre></td></tr></table></figure>

<p>系统会自动为方法增加abstract修饰符。</p>
<h1 id="java容器"><a href="#java容器" class="headerlink" title="java容器"></a>java容器</h1><p>Java的容器是前人为我们设计好的一套存储对象和数据的一套轮子，通过使用Java中写好的容器API我们可以很方便的存储、操作我们的数据。</p>
<h2 id="常用容器的图录（部分）"><a href="#常用容器的图录（部分）" class="headerlink" title="常用容器的图录（部分）"></a>常用容器的图录（部分）</h2><p><img src= "/img/loading.gif" data-src="https://pic3.zhimg.com/80/v2-37a924e5830ed38d9c76296314cb4baa_1440w.png" alt="java容器"></p>
<p>从图上可以看到，Java容器分为两大阵营：<strong>Collection</strong>和<strong>Map</strong></p>
<p><strong>Collection</strong>：主要是单个元素的集合，由List、Queue、Set三个接口区分不同的集合特征，然后由下面的具体的类来实现对应的功能。</p>
<p><strong>Map</strong>：有一组键值对的存储形式来保存，可以用键对象来查找值。</p>
<p>下面我们从Collection的三个接口开始，介绍每一个实现类之间的特色，让大家在处理不同的数据时选择合适的容器。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List的特点就是所有的元素是<strong>可以重复</strong>的。List接口在Collection的基础上增加了很多的方法。</p>
<p>List主要分为<strong>ArrayList</strong>和<strong>LinkedList</strong>，前者底层是使用数组实现的List，后者是使用链表实现的List。</p>
<p>Vector是一个已经被弃用的类，因为他是<strong>线程同步</strong>的，而我们平时使用的时候都是非同步的，使用同步的坏处就是会在一个记录上加锁，防止多个程序访问同一条数据导致数据不同步。这样会导致访问速度变慢。</p>
<p>Stack是满足“<strong>后进先出</strong>”规则的容器，注意LinkedList可以实现所有的栈功能。</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList是一个可以<strong>动态增长</strong>的数组。</p>
<p>我们都知道Java中的数组一旦指定了长度就不可以改变，如果我们在业务中需要使用动态的数组，就可以使用ArrayList。</p>
<p>ArrayList默认的长度是10，如果我们插入的数据超过了10，ArrayList会不断的自我增长。</p>
<p><strong>ArrayList由于底层是使用数组实现的，所以随机访问速度快，插入删除较慢</strong></p>
<p><strong>toArray：把LinkedList转化为Array</strong></p>
<h3 id="inkedList"><a href="#inkedList" class="headerlink" title="inkedList"></a>inkedList</h3><p>LinkedList是使用链表实现的容器。</p>
<p><strong>在列表中插入和删除速度快，但是查找需要遍历整个链表，速度较慢</strong><br>使用LinkedList可以实现很多队列、栈的数据结构，并且有很多方法很类似，但是有细小的差别</p>
<ul>
<li>getFirst和element都返回列表的头，但是不删除它，如果列表为空，抛出异常</li>
<li>peek实现的功能一样，但是列表为空时返回null</li>
<li>removeFirst和remove都是删除并返回列表的头，如果列表为空抛出异常</li>
<li>pool实现的功能一样，但是列表为空时返回null</li>
</ul>
<p>使用LinkedList可以实现一个栈的功能，下面让我们写一个属于自己的栈：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; storage = <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 进栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T v)</span></span>&#123;</span><br><span class="line">        storage.addFirst(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 窥视栈顶</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>队列是一个满足“<strong>先进先出</strong>”的数据结构。<br>LinkedList提供了方法支持队列操作，并且实现了Queue接口，所以LinkedList是队列的一种实现，可以通过LinkedList向上转型为Queue</p>
<ul>
<li>offer:将一个元素插入队尾</li>
<li>peek:不移除的情况下将元素插入队尾，队列为空返回null</li>
<li>element:不移除的情况下将元素插入队尾，队列为空报错</li>
<li>poll:移除并返回队头，队列为空返回null</li>
<li>remove:移除并返回队头，队列为空报错</li>
</ul>
<p>PriorityQueue是优先级队列，我们暂时先不介绍。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><strong>Set</strong></h2><p>set代表的是数学上的集合的意思，所以set中的元素不可以重复。<br>所以set中查找是最为重要的操作，而对于查找来说，我们最常用的就是HashSet</p>
<ul>
<li>HastSet底层是使用散列函数，在查询的方面有优化</li>
<li>TreeSet底层使用的是红黑树</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h2><p>Map是使用<strong>键值对</strong>存储的一种结构，所以在处理列如单词统计等方面是杀手锏。<br>Map的键值对都可以为null<br>Map可以多维扩展。例如一个人拥有多个宠物，你可以这样定义：<strong>Map&lt; Person, List&lt; pet&gt;&gt;</strong></p>
<ul>
<li>Object put(Object key, Object value):放进一个键值对，返回值是被替换的值</li>
<li>Object remove(Object key)</li>
<li>void putAll(Map mapping)</li>
<li>void clear()</li>
<li>boolean containsKey(Object key)是否包含某个键</li>
<li>boolean containsValue(Object value)是否包含某个值</li>
</ul>
<p>在Map中比较重要的是处理键值对的集合</p>
<ul>
<li>public Set keySet()：返回这个Map的所有键的集合，因为Map中键是唯一的，所以返回使用一个set</li>
<li>public Collection values()：返回这个Map的所有值的集合，因为值可能重复，所以返回一个Collection</li>
<li>public Set entrySet()：返回一个实现Map.Entry接口对象集合，使用这个方法可以遍历每一条记录。</li>
</ul>
<p>遍历Map示范代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, String&gt; file : films.entrySet())&#123;</span><br><span class="line">    String title = file.getKey();</span><br><span class="line">    String videoUrl = file.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HashMap更适合查找、删除、插入</strong><br><strong>TreeMap更适合遍历。</strong></p>
<h1 id="java异常"><a href="#java异常" class="headerlink" title="java异常"></a>java异常</h1><h2 id="异常概述"><a href="#异常概述" class="headerlink" title="异常概述"></a>异常概述</h2><p>​    Java的异常机制主要依赖于try、catch、finally、throw和throws五个关键字，其中try关键字后紧跟一个花括号扩起来的代码块（花括号不可省略），简称try块，它里面放置可能引发异常的代码。catch后对应异常类型和一个代码块，用于表明该catch块用于处理这种类型的代码块。多个catch块后还可以跟一个finally块，finally块用于回收在try块里打开的物理资源，异常机制会保证finally块总被执行。throws关键字主要在方法签名中使用，用于声明该方法可能抛出的异常；而throw用于抛出一个实际的异常，throw可以单独作为语句使用，抛出一个具体的异常对象。</p>
<p>​    Java 7进一步增强了异常处理机制的功能，包括带资源的try语句、捕获多异常的catch两个新功能，这两个功能可以极好地简化异常处理。</p>
<p>​    Java将异常分为两种，Checked异常和Runtime异常， Java认为Checked异常都是可以在编译阶段被处理的异常，所以它强制程序处理所有的Checked异常；而Runtime异常则无须处理。</p>
<p>​    当程序运行出现意外情形时，系统会自动生成一个Exception对象来通知程序，从而实现将“业务功能实现代码”和“错误处理代码”分离，提供更好的可读性。</p>
<h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><h3 id="使用try…catch捕获异常"><a href="#使用try…catch捕获异常" class="headerlink" title="使用try…catch捕获异常"></a>使用try…catch捕获异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//业务代码实现</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    alter 输入不合法</span><br><span class="line">    goto retry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果执行try块里的业务逻辑代码时出现异常，系统自动生成一个异常对象，该异常对象被提交给Java运行时环境，这个过程被称为抛出（throw）异常。</p>
<p>当Java运行时环境收到异常对象时，会寻找能处理该异常对象的catch块，如果找到合适的catch块，则把该异常对象交给该catch块处理，这个过程被称为捕获（catch）异常；如果Java运行时环境找不到捕获异常的catch块，则运行时环境终止，Java程序也将退出。</p>
<h3 id="异常类的继承体系"><a href="#异常类的继承体系" class="headerlink" title="异常类的继承体系"></a>异常类的继承体系</h3><p>Java提供了丰富的异常类，这些异常类之间有严格的继承关系，Java常见的异常类之间的继承关系：</p>
<p><img src= "/img/loading.gif" data-src="http://ww1.sinaimg.cn/large/ad3c4311gy1gm4qm9d4dvj20tw0l6jsz.jpg" alt></p>
<p>​    Java把所有的非正常情况分成两种：异常（Exception）和错误（Error），它们都继承Throwable父类。</p>
<p>​    Error错误，一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，这种错误无法恢复或不可能捕获，将导致应用程序中断。通常应用程序无法处理这些错误，因此应用程序不应该试图使用catch块来捕获Error对象。在定义该方法时，也无须在其throws子句中声明该方法可能抛出Error及其任何子类。</p>
<p>​    进行异常捕获时，一定要记住先捕获小异常，再捕获大异常。</p>
<h3 id="Java-7提供的多异常捕获"><a href="#Java-7提供的多异常捕获" class="headerlink" title="Java 7提供的多异常捕获"></a>Java 7提供的多异常捕获</h3><p>在Java 7以前，每个catch块只能捕获一种类型的异常；但从Java 7开始，一个catch块可以捕获多种类型的异常。使用一个catch块捕获多种类型的异常时需要注意如下两个地方。</p>
<ul>
<li>捕获多种类型的异常时，多种异常类型之间用竖线（|）隔开。</li>
<li>捕获多种类型的异常时，异常变量有隐式的final修饰，因此程序不能对异常变量重新赋值。</li>
</ul>
<h3 id="访问异常信息"><a href="#访问异常信息" class="headerlink" title="访问异常信息"></a>访问异常信息</h3><p>​    当Java运行时决定调用某个catch块来处理该异常对象时，会将异常对象赋给catch块后的<strong>异常参数</strong>，程序即可通过该参数来获得异常的相关信息。所有的异常对象都包含了如下几个常用方法。</p>
<ul>
<li>getMessage()：返回该异常的详细描述字符串。</li>
<li>printStackTrace()：将该异常的跟踪栈信息输出到标准错误输出。</li>
<li>printStackTrace(PrintStream s)：将该异常的跟踪栈信息输出到指定输出流。</li>
<li>getStackTrace()：返回该异常的跟踪栈信息。</li>
</ul>
<h3 id="使用finally回收资源"><a href="#使用finally回收资源" class="headerlink" title="使用finally回收资源"></a>使用finally回收资源</h3><p>​    有些时候，程序在try块里打开了一些物理资源（例如数据库连接、网络连接和磁盘文件等），这些物理资源都必须显式回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提示</span><br><span class="line">Java的垃圾回收机制不会回收任何物理资源，垃圾回收机制只能回收堆内存中对象所占用的内存。</span><br></pre></td></tr></table></figure>

<p>​    为了保证一定能回收try块中打开的物理资源，异常处理机制提供了finally块。不管try块中的代码是否出现异常，也不管哪一个catch块被执行，甚至在try块或catch块中执行了return语句，finally块总会被执行。完整的Java异常处理语法结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//业务代码实现</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SubException e)&#123;</span><br><span class="line">    <span class="comment">//异常处理1</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SubException e)&#123;</span><br><span class="line">    <span class="comment">//异常处理</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//资源回收块</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>异常处理语法结构中只有try块是必需的，也就是说，如果没有try块，则不能有后面的catch块和finally块；</li>
<li>catch块和finally块都是可选的，但catch块和finally块至少出现其中之一，也可以同时出现；</li>
<li>可以有多个catch块，捕获父类异常的catch块必须位于捕获子类异常的后面；</li>
<li>但不能只有try块，既没有catch块，也没有finally块；</li>
<li>多个catch块必须位于try块之后，finally块必须位于所有的catch块之后。</li>
</ul>
<h3 id="异常处理的嵌套"><a href="#异常处理的嵌套" class="headerlink" title="异常处理的嵌套"></a>异常处理的嵌套</h3><h3 id="Java-7的自动关闭资源的try语句"><a href="#Java-7的自动关闭资源的try语句" class="headerlink" title="Java 7的自动关闭资源的try语句"></a>Java 7的自动关闭资源的try语句</h3><h2 id="Checked异常和Runtime异常体系"><a href="#Checked异常和Runtime异常体系" class="headerlink" title="Checked异常和Runtime异常体系"></a>Checked异常和Runtime异常体系</h2><p>Java的异常被分为两大类：Checked异常和Runtime异常（运行时异常）。</p>
<p>所有的RuntimeException类及其子类的实例被称为Runtime异常；不是RuntimeException类及其子类的异常实例则被称为Checked异常。</p>
<p>Checked异常体现了Java的设计哲学——没有完善错误处理的代码根本就不会被执行！它要求程序员必须注意该异常——要么显式声明抛出，要么显式捕获并处理它，总之不允许对Checked异常不闻不问。</p>
<p>对于Checked异常的处理方式有如下两种。</p>
<ul>
<li>当前方法明确知道如何处理该异常，程序应该使用try…catch块来捕获该异常，然后在对应的catch块中修复该异常。例如，前面介绍的五子棋游戏中处理用户输入不合法的异常，程序在catch块中打印对用户的提示信息，重新开始下一次循环。</li>
<li>当前方法不知道如何处理这种异常，应该在定义该方法时声明抛出该异常。</li>
</ul>
<p>Runtime异常则更加灵活，Runtime异常无须显式声明抛出，如果程序需要捕获Runtime异常，也可以使用try…catch块来实现。</p>
<h3 id="使用throws声明抛出异常"><a href="#使用throws声明抛出异常" class="headerlink" title="使用throws声明抛出异常"></a>使用throws声明抛出异常</h3><p>​    使用throws声明抛出异常的思路是，当前方法不知道如何处理这种类型的异常，该异常应该由上一级调用者处理。JVM对异常的处理方法是，打印异常的跟踪栈信息，并中止程序运行，这就是前面程序在遇到异常后自动结束的原因。</p>
<p>​    throws声明抛出只能在方法签名中使用，throws可以声明抛出多个异常类，多个异常类之间以逗号隔开。</p>
<h2 id="使用throw抛出异常"><a href="#使用throw抛出异常" class="headerlink" title="使用throw抛出异常"></a>使用throw抛出异常</h2><p>​    当程序出现错误时，系统会自动抛出异常；除此之外，Java也允许程序自行抛出异常，自行抛出异常使用throw语句来完成（注意此处的throw没有后面的s，与前面声明抛出的throws是有区别的）。</p>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>​    如果需要在程序中自行抛出异常，则应使用throw语句，throw语句可以单独使用，throw语句抛出的不是异常类，而是一个异常实例，而且每次只能抛出一个异常实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"你试图下棋的坐标已经有棋子了"</span>);</span><br></pre></td></tr></table></figure>

<p>​    如果throw语句抛出的异常是Checked异常，则该throw语句要么处于try块里，显式捕获该异常，要么放在一个带throws声明抛出的方法中，即把该异常交给该方法的调用者处理；</p>
<p>​    如果throw语句抛出的异常是Runtime异常，则该语句无须放在try块里，也无须放在带throws声明抛出的方法中；程序既可以显式使用try…catch来捕获并处理该异常，也可以完全不理会该异常，把该异常交给该方法调用者处理。</p>
<h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><p>​    用户自定义异常都应该继承Exception基类，如果希望自定义Runtime异常，则应该继承RuntimeException基类。定义异常类时通常需要提供两个构造器：一个是无参数的构造器；另一个是带一个字符串参数的构造器，这个字符串将作为该异常对象的描述信息（也就是异常对象的getMessage()方法的返回值）。</p>
<h2 id="Java的异常跟踪栈"><a href="#Java的异常跟踪栈" class="headerlink" title="Java的异常跟踪栈"></a>Java的异常跟踪栈</h2><p>​    异常对象的printStackTrace()方法用于打印异常的跟踪栈信息，根据printStackTrace()方法的输出结果，我们可以找到异常的源头，并跟踪到异常一路触发的过程。</p>
<h1 id="java泛型"><a href="#java泛型" class="headerlink" title="java泛型"></a>java泛型</h1><h2 id="泛型入门"><a href="#泛型入门" class="headerlink" title="泛型入门"></a>泛型入门</h2><p>​    Java集合有个缺点：当我们把一个对象“丢进”集合里后，集合就会“忘记”这个对象的数据类型，当再次取出该对象时，该对象的编译类型就变成了Object类型（其运行时类型没变）。</p>
<p>​    Java集合之所以被设计成这样，是因为设计集合的程序员不会知道我们用它来保存什么类型的对象，所以他们把集合设计成能保存任何类型的对象，只要求具有很好的通用性。但这样做带来如下两个问题：</p>
<ul>
<li>集合对元素类型没有任何限制，这样可能引发一些问题。例如，想创建一个只能保存Dog对象的集合，但程序也可以轻易地将Cat对象“丢”进去，所以可能引发异常。</li>
<li>由于把对象“丢进”集合时，集合丢失了对象的状态信息，集合只知道它盛装的是Object，因此取出集合元素后通常还需要进行强制类型转换。这种强制类型转换既增加了编程的复杂度，也可能引发ClassCastException异常。</li>
</ul>
<p>​    从Java 5以后，Java引入了“参数化类型（parameterized type）”的概念，允许我们在创建集合时指定集合元素的类型，正如在第8章的ShowHand.java程序中见到的List<String>，这表明该List只能保存字符串类型的对象。Java的参数化类型被称为泛型（Generic）。</String></p>
<p>​    从Java 7开始，Java允许在构造器后不需要带完整的泛型信息，只要给出一对尖括号（&lt;&gt;）即可，Java可以推断尖括号里应该是什么泛型信息。即可以写为如下形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Map&lt;String , Integer&gt; scores=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="深入泛型"><a href="#深入泛型" class="headerlink" title="深入泛型"></a>深入泛型</h2><p>​    所谓泛型，就是允许在定义类、接口、方法时使用类型形参，这个类型形参将在声明变量、创建对象、调用方法时动态地指定（即传入实际的类型参数，也可称为类型实参）。</p>
<h3 id="从泛型类派生子类"><a href="#从泛型类派生子类" class="headerlink" title="从泛型类派生子类"></a>从泛型类派生子类</h3><p>​    当创建了带泛型声明的接口、父类之后，可以为该接口创建实现类，或从该父类派生子类，但需要指出的是，当使用这些接口、父类时不能再包含类型形参。</p>
<p>​    调用方法时必须为所有的数据形参传入参数值，与调用方法不同的是，使用类、接口时可以不为类型形参传入实际的类型参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类A继承Apple类，Apple类不能跟类型形参</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Apple</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Apple类时，为T形参传入String类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Apple</span>&lt;<span class="title">String</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Apple类时，没有为T形参传入实际类型参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Apple</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并不存在泛型类"><a href="#并不存在泛型类" class="headerlink" title="并不存在泛型类"></a>并不存在泛型类</h3><p>​    不管为泛型的类型形参传入哪一种类型实参，对于Java来说，它们依然被当成同一个类处理，在内存中也只占用一块内存空间，因此在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用类型形参。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//下面代码错误，不能在静态Field声明中使用类型形参</span></span><br><span class="line">    <span class="keyword">static</span> T info;</span><br><span class="line">    T age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(T msg)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面代码错误，不能在静态方法声明中使用类型形参</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(T msg)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于系统中并不会真正生成泛型类，所以instanceof运算符后不能使用泛型类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collection cs=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">//下面代码将引起错误，instanceof后不能使用泛型类</span></span><br><span class="line"><span class="keyword">if</span>(cs <span class="keyword">instanceof</span> List&lt;String&gt;)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h2><p>​        在Java的早期设计中，允许Integer[]数组赋值给Number[]变量存在缺陷，因此Java在泛型设计时进行了改进，它不再允许把List<Integer>对象赋值给List<Number>变量。</Number></Integer></p>
<p>​    Java泛型的设计原则是，只要代码在编译时没有出现警告，就不会遇到运行时ClassCastException异常。</p>
<p>​    数组和泛型有所不同，假设Foo是Bar的一个子类型（子类或者子接口），那么Foo[]依然是Bar[]的子类型；但G<Foo>不是G<Bar>的子类型。</Bar></Foo></p>
<h3 id="使用类型通配符"><a href="#使用类型通配符" class="headerlink" title="使用类型通配符"></a>使用类型通配符</h3><p>​    为了表示各种泛型List的父类，我们需要使用类型通配符，类型通配符是一个问号（?），将一个问号作为类型实参传给List集合，写作：List&lt;?&gt;（意思是未知类型元素的List）。这个问号（?）被称为通配符，它的元素类型可以匹配任何类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;?&gt; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c.size();i++)&#123;</span><br><span class="line">        System.out.println(c.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    现在使用任何类型的List来调用它，程序依然可以访问集合c中的元素，其类型是Object，这永远是安全的，因为不管List的真实类型是什么，它包含的都是类Object。</p>
<p>​    但这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素加入到其中。例如，如下代码将会引起编译错误。因为不知道c集合里元素的类型，所以不能向其中添加对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; c=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">//下面程序将引起编译错误</span></span><br><span class="line">c.add(<span class="keyword">new</span> Object());</span><br></pre></td></tr></table></figure>

<h3 id="设定类型通配符的上限"><a href="#设定类型通配符的上限" class="headerlink" title="设定类型通配符的上限"></a>设定类型通配符的上限</h3><p>​    当直接使用List<?>这种形式时，即表明这个List集合可以是任何泛型List的父类。但还有一种特殊的情形，我们不想使这个List<?>是任何泛型List的父类，只想表示它是某一类泛型List的父类。</p>
<p>​    List&lt;? extends Shape&gt;是受限制通配符的例子，此处的问号（?）代表一个未知的类型，就像前面看到的通配符一样。但是此处的这个未知类型一定是Shape的子类型（也可以是Shape本身），因此我们把Shape称为这个通配符的上限（upperbound）。因为不知道这个受限制的通配符的具体类型，所以不能把Shape对象或其子类的对象加入这个泛型集合中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRectangle</span><span class="params">(List&lt;? extend Shape&gt; shapes)</span></span>&#123;</span><br><span class="line">    <span class="comment">//下面代码将引起编译错误</span></span><br><span class="line">	shapes.add(<span class="number">0</span>,<span class="keyword">new</span> Rectangle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设定类型形参的上限"><a href="#设定类型形参的上限" class="headerlink" title="设定类型形参的上限"></a>设定类型形参的上限</h3><p>​    Java泛型不仅允许在使用<strong>通配符形参</strong>时设定上限，而且可以在定义<strong>类型形参</strong>时设定上限，用于表示传给该类型形参的实际类型要么是该上限类型，要么是该上限类型的子类。</p>
<p>​    在一种更极端的情况下，程序需要为类型形参设定多个上限（至多有一个父类上限，可以有多个接口上限），表明该类型形参必须是其父类的子类（是父类本身也行），并且实现多个上限接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&amp;<span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    与类同时继承父类、实现接口类似的是，为类型形参指定多个上限时，所有的<strong>接口上限必须位于类上限之后</strong>。</p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>​    Java 5提供了泛型方法（GenericMethod）。所谓泛型方法，就是在声明方法时定义一个或多个类型形参。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T,S&gt; 返回值类型 方法名(形参列表)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fromArrayToCollection</span><span class="params">(T[] a,Collection&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(T o:a)&#123;</span><br><span class="line">            c.add(o);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String[] sa=<span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">        Collection&lt;Object&gt; co=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        fromArrayToCollection(sa,co);</span><br><span class="line">        <span class="comment">//上面代码中co是一个Collection&lt;Object&gt;类型，与方法定义时的fromArrayToCollection(T[] a, Collection&lt;T&gt; c)进行泛型参数比较，不难发现该T类型形参代表的实际类型是Object类型。</span></span><br><span class="line">        </span><br><span class="line">        Number[] na=<span class="keyword">new</span> Number[<span class="number">10</span>];</span><br><span class="line">        Collection&lt;String&gt; co=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//因为Number类既不是String类，也不是String的子类，所以编译错误</span></span><br><span class="line">        fromArrayToCollection(na,cs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型方法和类型通配符的区别"><a href="#泛型方法和类型通配符的区别" class="headerlink" title="泛型方法和类型通配符的区别"></a>泛型方法和类型通配符的区别</h3><p>大多数时候都可以使用泛型方法来代替类型通配符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addsAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>&#123;&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> &lt;T&gt; containsAll(Collection&lt;T&gt; c)&#123;&#125;;</span><br><span class="line">    <span class="keyword">boolean</span> &lt;T&gt; addsAll(Collection&lt;T extends E&gt; c)&#123;&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    如果某个方法中一个形参（a）的类型或返回值的类型依赖于另一个形参（b）的类型，则形参（b）的类型声明不应该使用通配符——因为形参（a）或返回值的类型依赖于该形参（b）的类型，如果形参（b）的类型无法确定，程序就无法定义形参（a）的类型。在这种情况下，只能考虑使用在方法签名中声明类型形参——也就是泛型方法。</p>
<p>​    如果有需要，我们可以同时使用泛型方法和通配符，如Java的Collections.copy()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collection</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;T&gt; dest,List&lt;? extends T&gt; src)</span></span>&#123;&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    当然，也可以将上面的方法签名改为使用泛型方法，不使用类型通配符，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collection</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T,S extends T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;T&gt; dest,List&lt;S&gt; src)</span></span>&#123;&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-7的“菱形”语法与泛型构造器"><a href="#Java-7的“菱形”语法与泛型构造器" class="headerlink" title="Java 7的“菱形”语法与泛型构造器"></a>Java 7的“菱形”语法与泛型构造器</h3><p>​    正如泛型方法允许在方法签名中声明类型形参一样，Java也允许在构造器签名中声明类型形参，这样就产生了所谓的泛型构造器。</p>
<p>​    一旦定义了泛型构造器，接下来在调用构造器时，就不仅可以让Java根据数据参数的类型来“推断”类型形参的类型，而且程序员也可以显式地为构造器中的类型形参指定实际的类型。</p>
<p>​    前面介绍过Java 7新增的“菱形”语法，它允许调用构造器时在构造器后使用一对尖括号来代表泛型信息。但如果程序显式指定了泛型构造器中声明的类型形参的实际类型，则不可以使用“菱形”语法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; MyClass&lt;T t&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">"t参数的值为："</span>+t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDiamondTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyClass&lt;String&gt; mc1=<span class="keyword">new</span> MyClass&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        MyClass&lt;String&gt; mc2=<span class="keyword">new</span> &lt;Integer&gt; MyClass&lt;String&gt;(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//MyClass类声明中的E形参是String类型</span></span><br><span class="line">        <span class="comment">//如果显示指定泛型构造器中的T形参是Integer类型</span></span><br><span class="line">        <span class="comment">//此时就不能使用”菱形语法“，下面代码是错的</span></span><br><span class="line">        MyClass&lt;String&gt; mc3=<span class="keyword">new</span> &lt;Integer&gt; MyClass&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设定通配符下限"><a href="#设定通配符下限" class="headerlink" title="设定通配符下限"></a>设定通配符下限</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">copy</span><span class="params">(Collect&lt;T&gt; dest,Collect&lt;? extends T&gt; src)</span></span>&#123;</span><br><span class="line">    T last=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(T ele:src)&#123;</span><br><span class="line">        last=ele;</span><br><span class="line">        dest.add(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">copy</span><span class="params">(Collect&lt;? <span class="keyword">super</span> T&gt; dest,Collect&lt;T&gt; src)</span></span>&#123;</span><br><span class="line">    T last=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(T ele:src)&#123;</span><br><span class="line">        last=ele;</span><br><span class="line">        dest.add(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用? super T这种语句，就可以保证程序返回元素类型是T类型，而不是T的父类。</p>
<h3 id="泛型方法与方法重载"><a href="#泛型方法与方法重载" class="headerlink" title="泛型方法与方法重载"></a>泛型方法与方法重载</h3><p>​    因为泛型既允许设定通配符的上限，也允许设定通配符的下限，从而允许在一个类里包含如下两个方法定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUtils</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">copy</span><span class="params">(Collect&lt;T&gt; dest,Collect&lt;? extends T&gt; src)</span></span>&#123;</span><br><span class="line">        T last=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(T ele:src)&#123;</span><br><span class="line">            last=ele;</span><br><span class="line">            dest.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">copy</span><span class="params">(Collect&lt;? <span class="keyword">super</span> T&gt; dest,Collect&lt;T&gt; src)</span></span>&#123;</span><br><span class="line">        T last=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(T ele:src)&#123;</span><br><span class="line">            last=ele;</span><br><span class="line">            dest.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    如果这个类仅包含这两个方法不会有任何错误，但只要调用这个方法就会引起编译错误。</p>
<h3 id="擦除和转换"><a href="#擦除和转换" class="headerlink" title="擦除和转换"></a>擦除和转换</h3><h3 id="泛型与数组"><a href="#泛型与数组" class="headerlink" title="泛型与数组"></a>泛型与数组</h3><h1 id="java注解"><a href="#java注解" class="headerlink" title="java注解"></a>java注解</h1><p>​    Annotation是一个接口，程序可以通过反射来获取指定程序元素的Annotation对象，然后通过Annotation对象来取得注释里的元数据。</p>
<p>​    如果希望让程序中的Annotation在运行时起一定的作用，只有通过某种配套的工具对Annotation中的信息进行访问和处理，访问和处理Annotation的工具统称APT（AnnotationProcessing Tool）。</p>
<h2 id="基本Annotation"><a href="#基本Annotation" class="headerlink" title="基本Annotation"></a>基本Annotation</h2><p>4个基本的Annotation如下：</p>
<ul>
<li>@Override</li>
<li>@Deprecated</li>
<li>@SuppressWarnings</li>
<li>@SafeVarargs</li>
</ul>
<p>​    上面4个基本Annotation中的@SafeVarargs是Java 7新增的。这4个基本的Annotation都定义在java.lang包下。</p>
<p>​    @Override就是用来指定方法覆载的，它可以强制一个子类必须覆盖父类的方法。@Override只能作用于方法，不能作用于其他程序元素。</p>
<p>​    @Deprecated用于表示某个程序元素（类、方法等）已过时，当其他程序使用已过时的类、方法时，编译器将会给出警告。</p>
<p>​    @SuppressWarnings指示被该Annotation修饰的程序元素（以及该程序元素中的所有子元素）取消显示指定的编译器警告。</p>
<p>​    有些时候，开发者不希望看到”堆污染”警告，则可以使用如下3种方式来“抑制”这个警告。</p>
<ul>
<li>使用@SafeVarargs修饰引发该警告的方法或构造器。</li>
<li>使用@SuppressWarnings(“unchecked”)修饰。</li>
<li>编译时使用-Xlintvarargs选项。</li>
</ul>
<p>第3种方式一般比较少用，通常可以选择第1种或第2种方式，尤其是使用@SafeVarargs修饰引发该警告的方法或构造器，它是Java 7专门为抑制“堆污染”警告提供的。</p>
<h2 id="JDK的元Annotation"><a href="#JDK的元Annotation" class="headerlink" title="JDK的元Annotation"></a>JDK的元Annotation</h2><p>​    JDK除了在java.lang下提供了4个基本的Annotation之外，还在java.lang.annotation包下提供了4个Meta Annotation（元Annotation），这4个元Annotation都用于修饰其他的Annotation定义。</p>
<p>1、@Retention    </p>
<p>@Retention只能用于修饰一个Annotation定义，用于指定被修饰的Annotation可以保留多长时间，@Retention包含一个RetentionPolicy类型的value成员变量，所以使用@Retention时必须为该value成员变量指定值。</p>
<p>value成员变量的值只能是如下3个。</p>
<ul>
<li>RetentionPolicy.CLASS：编译器将把Annotation记录在class文件中。当运行Java程序时，JVM不再保留Annotation。这是默认值。</li>
<li>RetentionPolicy.RUNTIME：编译器将把Annotation记录在class文件中。当运行Java程序时， JVM也会保留Annotation，程序可以通过反射获取该Annotation信息。</li>
<li>RetentionPolicy.SOURCE：Annotation只保留在源代码中，编译器直接丢弃这种Annotation。</li>
</ul>
<p>2、@Target</p>
<p>​    @Target也只能修饰一个Annotation定义，它用于指定被修饰的Annotation能用于修饰哪些程序单元。@Target元Annotation也包含一个名为value的成员变量，该成员变量的值只能是如下几个。</p>
<ul>
<li>ElementType.ANNOTATION_TYPE：指定该策略的Annotation只能修饰Annotation。</li>
<li>ElementType.CONSTRUCTOR：指定该策略的Annotation只能修饰构造器。</li>
<li>ElementType.FIELD：指定该策略的Annotation只能修饰成员变量。</li>
<li>ElementType.LOCAL_VARIABLE：指定该策略的Annotation只能修饰局部变量。</li>
<li>ElementType.METHOD：指定该策略的Annotation只能修饰方法定义。</li>
<li>ElementType.PACKAGE：指定该策略的Annotation只能修饰包定义。</li>
<li>ElementType.PARAMETER：指定该策略的Annotation可以修饰参数。</li>
<li>ElementType.TYPE：指定该策略的Annotation可以修饰类、接口（包括注释类型）或枚举定义。</li>
</ul>
<p>3、@Documented</p>
<p>​    @Documented用于指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档，如果定义Annotation类时使用了@Documented修饰，则所有使用该Annotation修饰的程序元素的API文档中将会包含该Annotation说明。</p>
<p>4、@Inherited</p>
<p>​    @Inherited元Annotation指定被它修饰的Annotation将具有继承性——如果某个类使用了@A Annotation（定义该Annotation时使用了@Inherited修饰）修饰，则其子类将自动被@A修饰。</p>
<h2 id="自定义Annotation"><a href="#自定义Annotation" class="headerlink" title="自定义Annotation"></a>自定义Annotation</h2><p>1、定义Annotation    </p>
<p>​    定义新的Annotation类型使用@interface关键字（在原有的interface关键字前增加@符号）定义一个新的Annotation类型与定义一个接口非常像，如下代码可定义一个简单的Annotation类型。</p>
<p>​    Annotation不仅可以是这种简单的Annotation，还可以带成员变量，Annotation的成员变量在Annotation定义中以无形参的方法形式来声明，其方法名和返回值定义了该成员变量的名字和类型。如下代码可以定义一个有成员变量的Annotation。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTag&#123;</span><br><span class="line">	<span class="comment">//定义了两个成员变量</span></span><br><span class="line">    <span class="comment">//Annotation中的成员变量以方法的形式来定义</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、提取Annotation信息</p>
<p>​    当开发者使用Annotation修饰了类、方法、Field等成员之后，这些Annotation不会自己生效，必须由开发者提供相应的工具来提取并处理Annotation信息。</p>
<p>​    Java使用Annotation接口来代表程序元素前面的注释，该接口是所有Annotation类型的父接口。Java 5在java.lang.reflect包下新增了AnnotatedElement接口，该接口代表程序中可以接受注释的程序元素。该接口主要有如下几个实现类。</p>
<ul>
<li>Class：类定义。</li>
<li>Constructor：构造器定义。</li>
<li>Field：类的成员变量定义。</li>
<li>Method：类的方法定义。</li>
<li>Package：类的包定义。</li>
</ul>
<h2 id="使用Annotation的示例"><a href="#使用Annotation的示例" class="headerlink" title="使用Annotation的示例"></a>使用Annotation的示例</h2><p>​    第一个AnnotationTestable没有任何成员变量，仅是一个标记Annotation，它的作用是标记哪些方法是可测试的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用JDK的元数据Annotation：@Retention</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">//使用JDK的元数据Annotation：@Target</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="comment">//定义一个标记注释，不包含任何成员变量，即不可传入元数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Testable&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    定义该Annotation时使用了@Retention和@Target两个JDK的元注释，其中@Retention注释指定Testable注释可以保留到运行时（JVM会提取该Annotation），而@Target注释指定@Testable只能修饰方法。</p>
<p>​    下面MyTest测试用例中定义了8个方法，这8个方法没有太大的区别，其中4个方法使用@Testable注释来标记这些方法是可测试的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用@Testable标记注释指定该方法是可测试的</span></span><br><span class="line">    <span class="meta">@Testable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> m1&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> m2&#123;&#125;</span><br><span class="line">    <span class="comment">//使用@Testable标记注释指定该方法是可测试的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> m3&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Boom"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> m4&#123;&#125;</span><br><span class="line">    <span class="comment">//使用@Testable标记注释指定该方法是可测试的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> m5&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> m6&#123;&#125;</span><br><span class="line">    <span class="comment">//使用@Testable标记注释指定该方法是可测试的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> m7&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Crash"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> m8&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessorTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String clazz)</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> passed=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> failed=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Method m:Class.forName(clazz).getMethods())&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.isAnnoattionPresent(Testable<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    m.invoke(<span class="keyword">null</span>);</span><br><span class="line">                    passed++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"方法"</span>+m+<span class="string">"运行失败，异常："</span>+ex.getCause());</span><br><span class="line">                    failed++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(passed+<span class="string">"\t"</span>+failed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        process(<span class="string">"MyTest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    可见Annotation是对源代码增加的一些特殊标记，这些特殊标记可通过反射获取，当程序获取这些特殊标记后，程序可以做出相应的处理（当然也可以完全忽略这些Annotation）。</p>
<h2 id="编译时处理Annotation"><a href="#编译时处理Annotation" class="headerlink" title="编译时处理Annotation"></a>编译时处理Annotation</h2><p>​    APT（Annotation Processing Tool）是一种处理注释的工具，它对源代码文件进行检测找出其中的Annotation后，对Annotation进行额外的处理。</p>
<p>​    Annotation处理器在处理Annotation时可以根据源文件中的Annotation生成额外的源文件和其他的文件（文件的具体内容由Annotation处理器的编写者决定），APT还会编译生成的源代码文件和原来的源文件，将它们一起生成class文件。</p>
<h1 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h1><p>​    反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</p>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//正常的调用</span></span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        apple.setPrice(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"Apple Price:"</span> + apple.getPrice());</span><br><span class="line">        <span class="comment">//使用反射调用</span></span><br><span class="line">        Class clz = Class.forName(<span class="string">"com.chenshuyi.api.Apple"</span>);</span><br><span class="line">        Method setPriceMethod = clz.getMethod(<span class="string">"setPrice"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Constructor appleConstructor = clz.getConstructor();</span><br><span class="line">        Object appleObj = appleConstructor.newInstance();</span><br><span class="line">        setPriceMethod.invoke(appleObj, <span class="number">14</span>);</span><br><span class="line">        Method getPriceMethod = clz.getMethod(<span class="string">"getPrice"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Apple Price:"</span> + getPriceMethod.invoke(appleObj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用反射获取一个对象的步骤：</p>
<ol>
<li>获取类的 Class 对象实例</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Class.forName(<span class="string">"com.zhenai.api.Apple"</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据 Class 对象实例获取 Constructor 对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor appleConstructor = clz.getConstructor();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 Constructor 对象的 newInstance 方法获取反射类对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object appleObj = appleConstructor.newInstance();</span><br></pre></td></tr></table></figure>

<p>而如果要调用某一个方法，则需要经过下面的步骤：</p>
<ol>
<li>获取方法的 Method 对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method setPriceMethod = clz.getMethod(<span class="string">"setPrice"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用 invoke 方法调用方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setPriceMethod.invoke(appleObj, <span class="number">14</span>);</span><br></pre></td></tr></table></figure>

<p>​    到这里，我们已经能够掌握反射的基本使用。但如果要进一步掌握反射，还需要对反射的常用 API 有更深入的理解。在 JDK 中，反射相关的 API 可以分为下面几个方面：获取反射的 Class 对象、通过反射创建类对象、通过反射获取类属性方法及构造器。</p>
<h2 id="反射常用API"><a href="#反射常用API" class="headerlink" title="反射常用API"></a>反射常用API</h2><h3 id="获取反射中的Class对象"><a href="#获取反射中的Class对象" class="headerlink" title="获取反射中的Class对象"></a>获取反射中的Class对象</h3><p>在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。</p>
<p>在 Java API 中，获取 Class 类对象有三种方法：</p>
<ol>
<li>使用 Class.forName 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 .class 方法。</li>
</ol>
<p>这种方法只适合在编译前就知道操作的 Class。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz = String<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用类对象的 getClass() 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br><span class="line">Class clz = str.getClass();</span><br></pre></td></tr></table></figure>

<h3 id="通过反射创建类对象"><a href="#通过反射创建类对象" class="headerlink" title="通过反射创建类对象"></a>通过反射创建类对象</h3><p>通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。</p>
<ol>
<li>通过 Class 对象的 newInstance() 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Apple<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Apple apple = (Apple)clz.newInstance();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过 Constructor 对象的 newInstance() 方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Apple<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor constructor = clz.getConstructor();</span><br><span class="line">Apple apple = (Apple)constructor.newInstance();</span><br></pre></td></tr></table></figure>

<p>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Apple<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor constructor = clz.getConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">Apple apple = (Apple)constructor.newInstance(<span class="string">"红富士"</span>, <span class="number">15</span>);</span><br></pre></td></tr></table></figure>

<h3 id="通过反射获取类属性、方法、构造器"><a href="#通过反射获取类属性、方法、构造器" class="headerlink" title="通过反射获取类属性、方法、构造器"></a>通过反射获取类属性、方法、构造器</h3><p>我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Apple<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Field[] fields = clz.getFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">price</span><br></pre></td></tr></table></figure>

<p>而如果使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Apple<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Field[] fields = clz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。</p>
<h2 id="反射源码解析"><a href="#反射源码解析" class="headerlink" title="反射源码解析"></a>反射源码解析</h2><p>​    当我们懂得了如何使用反射后，今天我们就来看看 JDK 源码中是如何实现反射的。或许大家平时没有使用过反射，但是在开发 Web 项目的时候会遇到过下面的异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException </span><br><span class="line">...</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:497)</span><br></pre></td></tr></table></figure>

<p>可以看到异常堆栈指出了异常在 Method 的第 497 的 invoke 方法中，其实这里指的 invoke 方法就是我们反射调用方法中的 invoke。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = clz.getMethod(<span class="string">"setPrice"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">method.invoke(object, <span class="number">4</span>);   <span class="comment">//就是这里的invoke方法</span></span><br></pre></td></tr></table></figure>

<p>例如我们经常使用的 Spring 配置中，经常会有相关 Bean 的配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.chenshuyi.Apple"</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>​    当我们在 XML 文件中配置了上面这段配置之后，Spring 便会在启动的时候利用反射去加载对应的 Apple 类。而当 Apple 类不存在或发生启发异常时，异常堆栈便会将异常指向调用的 invoke 方法。</p>
<p>​    从这里可以看出，我们平常很多框架都使用了反射，而反射中最最终的就是 Method 类的 invoke 方法了。</p>
<p>​    下面我们来看看 JDK 的 invoke 方法到底做了些什么。</p>
<p>​    进入 Method 的 invoke 方法我们可以看到，一开始是进行了一些权限的检查，最后是调用了 MethodAccessor 类的 invoke 方法进行进一步处理，如下图红色方框所示。</p>
<p><img src= "/img/loading.gif" data-src="https://pic4.zhimg.com/80/v2-c99a54c0223fbe19a9144126f1b3b483_1440w.jpg" alt="img"></p>
<p>那么 MethodAccessor 又是什么呢？</p>
<p>其实 MethodAccessor 是一个接口，定义了方法调用的具体操作，而它有三个具体的实现类：</p>
<ul>
<li>sun.reflect.DelegatingMethodAccessorImpl</li>
<li>sun.reflect.MethodAccessorImpl</li>
<li>sun.reflect.NativeMethodAccessorImpl</li>
</ul>
<p>而要看 ma.invoke() 到底调用的是哪个类的 invoke 方法，则需要看看 MethodAccessor 对象返回的到底是哪个类对象，所以我们需要进入 acquireMethodAccessor() 方法中看看。</p>
<p><img src= "/img/loading.gif" data-src="https://pic4.zhimg.com/80/v2-7b1df98b40fe7d6d6574746e3bf08e77_1440w.jpg" alt="img"></p>
<p>​    从 acquireMethodAccessor() 方法我们可以看到，代码先判断是否存在对应的 MethodAccessor 对象，如果存在那么就复用之前的 MethodAccessor 对象，否则调用 ReflectionFactory 对象的 newMethodAccessor 方法生成一个 MethodAccessor 对象。</p>
<p><img src= "/img/loading.gif" data-src="https://pic1.zhimg.com/80/v2-323cb636f0f8caa3b95640c0e03330d0_1440w.jpg" alt="img"></p>
<p>​    在 ReflectionFactory 类的 newMethodAccessor 方法里，我们可以看到首先是生成了一个 NativeMethodAccessorImpl 对象，再这个对象作为参数调用 DelegatingMethodAccessorImpl 类的构造方法。</p>
<p>​    这里的实现是使用了代理模式，将 NativeMethodAccessorImpl 对象交给 DelegatingMethodAccessorImpl 对象代理。我们查看 DelegatingMethodAccessorImpl 类的构造方法可以知道，其实是将 NativeMethodAccessorImpl 对象赋值给 DelegatingMethodAccessorImpl 类的 delegate 属性。</p>
<p><img src= "/img/loading.gif" data-src="https://pic2.zhimg.com/80/v2-5f95eca8b7a08cf9abf27d8a378e6799_1440w.jpg" alt="img"></p>
<p>所以说ReflectionFactory 类的 newMethodAccessor 方法最终返回 DelegatingMethodAccessorImpl 类对象。所以我们在前面的 ma.invoke() 里，其将会进入 DelegatingMethodAccessorImpl 类的 invoke 方法中。</p>
<p><img src= "/img/loading.gif" data-src="https://pic2.zhimg.com/80/v2-a12739735d1738d55b181efc5ca6e145_1440w.jpg" alt="img"></p>
<p>进入 DelegatingMethodAccessorImpl 类的 invoke 方法后，这里调用了 delegate 属性的 invoke 方法，它又有两个实现类，分别是：DelegatingMethodAccessorImpl 和 NativeMethodAccessorImpl。按照我们前面说到的，这里的 delegate 其实是一个 NativeMethodAccessorImpl 对象，所以这里会进入 NativeMethodAccessorImpl 的 invoke 方法。</p>
<p><img src= "/img/loading.gif" data-src="https://pic4.zhimg.com/80/v2-7fd614dd2bf14a79aa046a2c02e638d3_1440w.jpg" alt="img"></p>
<p>​    而在 NativeMethodAccessorImpl 的 invoke 方法里，其会判断调用次数是否超过阀值（numInvocations）。如果超过该阀值，那么就会生成另一个MethodAccessor 对象，并将原来 DelegatingMethodAccessorImpl 对象中的 delegate 属性指向最新的 MethodAccessor 对象。</p>
<p>​    到这里，其实我们可以知道 MethodAccessor 对象其实就是具体去生成反射类的入口。通过查看源码上的注释，我们可以了解到 MethodAccessor 对象的一些设计信息。</p>
<blockquote>
<p>“Inflation” mechanism. Loading bytecodes to implement Method.invoke() and Constructor.newInstance() currently costs 3-4x more than an invocation via native code for the first invocation (though subsequent invocations have been benchmarked to be over 20x faster).Unfortunately this cost increases startup time for certain applications that use reflection intensively (but only once per class) to bootstrap themselves.<br>Inflation 机制。初次加载字节码实现反射，使用 Method.invoke() 和 Constructor.newInstance() 加载花费的时间是使用原生代码加载花费时间的 3 - 4 倍。这使得那些频繁使用反射的应用需要花费更长的启动时间。<br>To avoid this penalty we reuse the existing JVM entry points for the first few invocations of Methods and Constructors and then switch to the bytecode-based implementations. Package-private to be accessible to NativeMethodAccessorImpl and NativeConstructorAccessorImpl.<br>为了避免这种痛苦的加载时间，我们在第一次加载的时候重用了 JVM 的入口，之后切换到字节码实现的实现。</p>
</blockquote>
<p>就像注释里说的，实际的 MethodAccessor 实现有两个版本，一个是 Native 版本，一个是 Java 版本。</p>
<p>Native 版本一开始启动快，但是随着运行时间边长，速度变慢。Java 版本一开始加载慢，但是随着运行时间边长，速度变快。正是因为两种存在这些问题，所以第一次加载的时候我们会发现使用的是 NativeMethodAccessorImpl 的实现，而当反射调用次数超过 15 次之后，则使用 MethodAccessorGenerator 生成的 MethodAccessorImpl 对象去实现反射。</p>
<p>Method 类的 invoke 方法整个流程可以表示成如下的时序图：</p>
<p><img src= "/img/loading.gif" data-src="https://pic1.zhimg.com/80/v2-09c4da108c3170451dcfff36bf92e50c_1440w.jpg" alt="img"></p>
<p>​    讲到这里，我们了解了 Method 类的 invoke 方法的具体实现方式。知道了原来 invoke 方法内部有两种实现方式，一种是 native 原生的实现方式，一种是 Java 实现方式，这两种各有千秋。而为了最大化性能优势，JDK 源码使用了代理的设计模式去实现最大化性能。</p>
<p>作者： 陈树义</p>
<p>链接：<a href="https://link.zhihu.com/?target=http%3A//www.imooc.com/article/details/id/23418">http://www.imooc.com/article/details/id/23418</a></p>
<h1 id="java-I-O"><a href="#java-I-O" class="headerlink" title="java I/O"></a>java I/O</h1><h2 id="IO概念"><a href="#IO概念" class="headerlink" title="IO概念"></a>IO概念</h2><p>• I/O 即输入Input/ 输出Output的缩写，其实就是计算机调度把各个存储中（包括内存和外部存储）的数据写入写出的过程；</p>
<p>• java中用“流（stream）”来抽象表示这么一个写入写出的功能，封装成一个“类”，都放在<a href="https://link.zhihu.com/?target=http%3A//java.io">http://java.io</a>这个包里面。</p>
<h2 id="“流”是什么？"><a href="#“流”是什么？" class="headerlink" title="“流”是什么？"></a>“流”是什么？</h2><p>​    通过“流”的形式允许java程序使用相同的方式来访问不同的输入/输出源。stream是从起源（source）到接收的（sink）的有序数据。我们这里把输入/输出源对比成“水桶”，那么流就是“管道”，这个“管道”的粗细、单向性等属性也就是区分了不同“流”的特性。</p>
<p><img src= "/img/loading.gif" data-src="https://pic3.zhimg.com/80/v2-e07aa9ad002a27f78381a3ae2978d5a6_1440w.jpg" alt="img"></p>
<h2 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h2><p>可以从三个不同的维度进行分类：</p>
<h3 id="按照流的方向"><a href="#按照流的方向" class="headerlink" title="按照流的方向"></a>按照流的方向</h3><p>输出输入都是站在程序所在内存的角度划分的。</p>
<p>• 输入流：只能从中读取数据【主要由InputStream和Reader作为基类】</p>
<p>• 输出流：只能向其写入数据【主要由outputStream和Writer作为基类】</p>
<p>在下图中，从磁盘读取数据到内存是输入流，从client读取数据到server是输入流；同样，把内存数据写到磁盘是输出流，把server数据写到client是输出流。</p>
<p><img src= "/img/loading.gif" data-src="https://pic2.zhimg.com/80/v2-1fa28fb1674675d9ee0e6f73d25a7ccd_1440w.jpg" alt="img"></p>
<h3 id="按照流的操作颗粒度划分"><a href="#按照流的操作颗粒度划分" class="headerlink" title="按照流的操作颗粒度划分"></a>按照流的操作颗粒度划分</h3><p>• 字节流：以字节为单元，可操作任何数据【主要由InputStream和outPutStream作为基类】</p>
<p>• 字符流：以字符为单元，只能操作纯字符数据，比较方便【主要由Reader和Writer作为基类】</p>
<h3 id="按照流的角色划分"><a href="#按照流的角色划分" class="headerlink" title="按照流的角色划分"></a>按照流的角色划分</h3><p>• 节点流：可以从/向一个特定的IO设备（如磁盘，网络）读/写数据的流，也叫低级流。</p>
<p>• 处理流：用于对一个已存在的流进行连接和封装，通过封装后的流来实现数据的读/写功能，也叫高级流。</p>
<p>下图中可以看出来，<strong>处理流就是在基础的字节流上，进行了封装，增加了特定的功能，</strong>使得传输更适合特定的场景。</p>
<p><img src= "/img/loading.gif" data-src="https://pic1.zhimg.com/80/v2-e1afd7f4862e6608cf4103fe5425e7a4_1440w.jpg" alt="img"></p>
<h2 id="流的原理以及IO流汇总"><a href="#流的原理以及IO流汇总" class="headerlink" title="流的原理以及IO流汇总"></a>流的原理以及IO流汇总</h2><h3 id="流的原理解析"><a href="#流的原理解析" class="headerlink" title="流的原理解析"></a>流的原理解析</h3><p>​    流其实我们可以想象成一个“水管”，源端和目的端就是两个“水桶”，数据是通过这个“水管”进行流动传输的，以InputStream和Reader为例，水管的每个“水滴”就是具体的数据，如果是字节流，那么一个“水滴”就是一个字节，如果是字符流，那么一个“水滴”就是一个字符。</p>
<p>​    当创建一个流对象的时候，如fis=new FileInputStream（“…\xx\xx.txt”），记录指针来表示当前正准备从哪个“水滴”开始读取，每当程序从InputStream或者Reader里面取出一个或者多个“水滴”后，记录指针自定向后移动；除此之外，InputStream和Reader里面都提供了一些方法来控制记录指针的移动。</p>
<p><img src= "/img/loading.gif" data-src="https://pic4.zhimg.com/80/v2-ffaadef46428b8edd181179354fcfb4b_1440w.jpg" alt="img"></p>
<p>如果是处理流的话，就相当于在这个水管上面装了一些“控制阀门”，最终用户只要关心“阀门”具备的能力就行</p>
<p><img src= "/img/loading.gif" data-src="https://pic2.zhimg.com/80/v2-81a02caf013acea77a2a9862de7117ed_1440w.jpg" alt="img"></p>
<h3 id="java中所有流汇总"><a href="#java中所有流汇总" class="headerlink" title="java中所有流汇总"></a>java中所有流汇总</h3><p>​    java.io中子类有40个“流”类，我们用以下表格来综合划分，当然这些流你不用都去花时间一个一个看过来，我们只要熟悉掌握几类常用的“流”就足够了，后续项目中如果用到陌生的“流”，知道原理的话可以快速地去检索学习下就ok了。</p>
<p><img src= "/img/loading.gif" data-src="https://pic2.zhimg.com/80/v2-62650876c872cf4f13dfbfc4f8b648c1_1440w.jpg" alt="img"></p>
<p>​    上图中我们可以看到，InputStream/Reader，OutputStream/Writer 是整个I/O体系的基类，他们本身不能用来创建实例，下面开始逐一对常见的I/O类进行实战。</p>
<h2 id="常见IO流的实战"><a href="#常见IO流的实战" class="headerlink" title="常见IO流的实战"></a>常见IO流的实战</h2><h3 id="访问操作文件"><a href="#访问操作文件" class="headerlink" title="访问操作文件"></a>访问操作文件</h3><p>FileInputStream/FileReader ，FileOutputStream/FileWriter</p>
<p>​    FileInputStream中包含以使用FileInputStream为例，类中包含的属性及方法，我们可以在线查看jdk的api文档<a href="https://link.zhihu.com/?target=http%3A//tool.oschina.net/apidocs/apidoc%3Fapi%3Djdk-zh">http://tool.oschina.net/apidocs/apidoc?api=jdk-zh</a>），下面只是截图了FileInputStream的构造方法：</p>
<p><img src= "/img/loading.gif" data-src="https://pic2.zhimg.com/80/v2-0c0390486234e396b56158355965a429_1440w.jpg" alt="img"></p>
<p>（1）使用FileInputStream，从文件读取数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileImportStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">		FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		in =<span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\41639\\Desktop\\java\\FileText\\src\\TestFileImportStream.java"</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">			System.out.println(<span class="string">"file is not found"</span>);</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">long</span> num=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> ((b=in.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">				System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line">			in.close();</span><br><span class="line">			System.out.println();</span><br><span class="line">			System.out.println(<span class="string">"共读取了"</span>+num+<span class="string">"个字节"</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"IO异常，读取失败"</span>);</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>（2）使用FileOutputStream，往文件里写数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFileOutputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">		FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">		FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		in =<span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\41639\\Desktop\\java\\FileText\\src\\TestFileImportStream.java"</span>);</span><br><span class="line">		out=<span class="keyword">new</span> FileOutputStream(<span class="string">"C:\\Users\\41639\\Desktop\\java\\temp\\out.java"</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">			System.out.println(<span class="string">"file is not found"</span>);</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> ((b=in.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">				out.write(b);</span><br><span class="line">			&#125;</span><br><span class="line">			in.close();</span><br><span class="line">			out.close();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"IO异常，读取失败"</span>);</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"文件复制完成"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存流的使用"><a href="#缓存流的使用" class="headerlink" title="缓存流的使用"></a>缓存流的使用</h3><p>BufferedInputStream/BufferedOutputStream，BufferedReader/BufferedWriter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBufferStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">		BufferedInputStream bis=<span class="keyword">null</span>;</span><br><span class="line">		BufferedOutputStream bos=<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\41639\\Desktop\\java\\FileText\\src\\TestFileImportStream.java"</span>);</span><br><span class="line">			FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"C:\\Users\\41639\\Desktop\\java\\temp\\out2.java"</span>);</span><br><span class="line">			bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">			bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">			<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="keyword">int</span> off=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> ((off=bis.read(b))&gt;<span class="number">0</span>) &#123;</span><br><span class="line">				bos.write(b,<span class="number">0</span>,off);</span><br><span class="line">			&#125;</span><br><span class="line">			bis.close();</span><br><span class="line">			bos.close();</span><br><span class="line">		&#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			bis.close();</span><br><span class="line">			bos.close();</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    从代码中可以看到，他们最基本的其实也是FileInputStream和FileOutputStream，在这个“流”的基础上，又加了缓存的功能流BufferedInputStream和BufferedOutputStream。相对比较好理解。</p>
<h3 id="转换流的使用"><a href="#转换流的使用" class="headerlink" title="转换流的使用"></a>转换流的使用</h3><p>InputStreamReader/OutputStreamWriter</p>
<p>字面意思理解，转化流就是用来转化的，那么到底是什么转什么呢？我们可以通过以下的例子来熟悉。读取键盘输入的每一行内容，并写入到文本中，直到遇到over行结束输入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransStreamTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"C:\\Users\\41639\\Desktop\\java\\temp\\test1031.txt"</span>));</span><br><span class="line">		String line =<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span> ((line=br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">"over"</span>.contentEquals(line)) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			bw.write(line);</span><br><span class="line">			bw.newLine();</span><br><span class="line">			bw.flush();</span><br><span class="line">		&#125;</span><br><span class="line">    bw.close();</span><br><span class="line">    br.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    readLine()方法在进行读取一行时，只有遇到回车(\r)或者换行符(\n)才会返回读取结果，这就是“读取一行的意思”，有兴趣的同学查看readLine()源码。</p>
<h3 id="对象流的使用"><a href="#对象流的使用" class="headerlink" title="对象流的使用"></a>对象流的使用</h3><p>FileInputStream/ObjectOutputStream</p>
<p>​    前面讲了字节和字符流，包括封装在他们上面的处理流，那么我们想，在程序设计的过程中，我们都是用类和对象来描述定义，能不能直接把对象进行传输。答案当然是肯定的，对象流其实就是一种特殊的处理流水，也是在基础的字节流上去作封装。</p>
<p>下面程序使用一个对象流，把对象直接写到文件中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStreamTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Person P=<span class="keyword">new</span> Person(<span class="string">"Jeccica"</span>,<span class="number">26</span>);</span><br><span class="line">			FileOutputStream fos=<span class="keyword">new</span> FileOutputStream(<span class="string">"C:\\Users\\admin\\Desktop\\Java\\temp\\22.txt"</span>);</span><br><span class="line">			ObjectOutputStream oos=<span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">			oos.writeObject(P);</span><br><span class="line">			oos.flush();</span><br><span class="line">			oos.close();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;			</span><br><span class="line">		</span><br><span class="line">		FileInputStream fis=<span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\admin\\Desktop\\Java\\temp\\22.txt"</span>);</span><br><span class="line">		ObjectInputStream ois=<span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">		Person P2=(Person)ois.readObject();</span><br><span class="line">		System.out.println(P2.name+<span class="string">"的年龄为"</span>+P2.age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	String name=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">int</span> age=<span class="number">0</span>;</span><br><span class="line">	Person(String _name,<span class="keyword">int</span> _age)&#123;</span><br><span class="line">		name=_name;</span><br><span class="line">		age=_age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节数组流的使用"><a href="#字节数组流的使用" class="headerlink" title="字节数组流的使用"></a>字节数组流的使用</h3><p>ByteArrayInputStream/ByteArrayOutputStream，通常结合数据流DataInputStream/DataOutputStream</p>
<p>​    我们分析了常见的节点流和常见的处理流等，经常而言我们都是针对文件的操作，然后带上缓冲的节点流进行处理，但有时候为了提升效率，我们发现频繁的读写文件并不是太好，那么于是出现了字节数组流，即存放在内存中，因此有称之为内存流；其中字节数组流也一种节点流；除了节点流外，我们也将学习另外一种处理流，即数据流。数据处理流是用于针对数据类型传输处理的，是一种处理流，即是在节点流之上的增强处理，一般用于序列化和反序列化的时候用到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ByteArrayOutputStream baos=<span class="keyword">new</span> ByteArrayOutputStream();<span class="comment">//创建字节数组流，同时会在内存里面创建数组</span></span><br><span class="line">		DataOutputStream dos=<span class="keyword">new</span> DataOutputStream(baos);<span class="comment">//对字节数组流外封装成数据处理流</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			dos.writeDouble(Math.random());<span class="comment">//利用数据流里面的写入方法，写一个Double类型的随机数据</span></span><br><span class="line">			dos.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">			ByteArrayInputStream bias=<span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());<span class="comment">//toByteArray()方法是创建一个新分配的字节数组。数组的大小和当前输出流的大小。这里指的是baos这个字节数组。</span></span><br><span class="line">			System.out.println(bias.available());</span><br><span class="line">			DataInputStream dis=<span class="keyword">new</span> DataInputStream(bias);</span><br><span class="line">			System.out.println(dis.readDouble());</span><br><span class="line">			System.out.println(dis.readBoolean());		</span><br><span class="line">			dos.close();</span><br><span class="line">			dis.close();</span><br><span class="line">		&#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者：李白写代码</p>
<p>链接：<a href="https://zhuanlan.zhihu.com/p/98094713" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/98094713</a></p>
<h1 id="java图形化"><a href="#java图形化" class="headerlink" title="java图形化"></a>java图形化</h1></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">dabing693</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2021/09/07/java%E9%AB%98%E7%BA%A7/">http://yoursite.com/2021/09/07/java%E9%AB%98%E7%BA%A7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">小辉博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/07/Mybatis%20IDEA%E7%89%88%E6%95%99%E7%A8%8B/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Mybatis IDEA版教程</div></div></a></div><div class="next-post pull-right"><a href="/2021/09/07/javaweb/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">javaweb教程</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By dabing693</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/js/hideMobileSidebar.js"></script></body></html>